{"ast":null,"code":"// Generated by LiveScript 1.4.0\nvar each,\n    map,\n    compact,\n    filter,\n    reject,\n    partition,\n    find,\n    head,\n    first,\n    tail,\n    last,\n    initial,\n    empty,\n    reverse,\n    unique,\n    uniqueBy,\n    fold,\n    foldl,\n    fold1,\n    foldl1,\n    foldr,\n    foldr1,\n    unfoldr,\n    concat,\n    concatMap,\n    _flatten,\n    difference,\n    intersection,\n    union,\n    countBy,\n    groupBy,\n    andList,\n    orList,\n    any,\n    all,\n    sort,\n    sortWith,\n    sortBy,\n    sum,\n    product,\n    mean,\n    average,\n    maximum,\n    minimum,\n    maximumBy,\n    minimumBy,\n    scan,\n    scanl,\n    scan1,\n    scanl1,\n    scanr,\n    scanr1,\n    slice,\n    take,\n    drop,\n    splitAt,\n    takeWhile,\n    dropWhile,\n    span,\n    breakList,\n    zip,\n    zipWith,\n    zipAll,\n    zipAllWith,\n    at,\n    elemIndex,\n    elemIndices,\n    findIndex,\n    findIndices,\n    toString$ = {}.toString,\n    slice$ = [].slice;\n\neach = curry$(function (f, xs) {\n  var i$, len$, x;\n\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n    f(x);\n  }\n\n  return xs;\n});\nmap = curry$(function (f, xs) {\n  var i$,\n      len$,\n      x,\n      results$ = [];\n\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n    results$.push(f(x));\n  }\n\n  return results$;\n});\n\ncompact = function compact(xs) {\n  var i$,\n      len$,\n      x,\n      results$ = [];\n\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n\n    if (x) {\n      results$.push(x);\n    }\n  }\n\n  return results$;\n};\n\nfilter = curry$(function (f, xs) {\n  var i$,\n      len$,\n      x,\n      results$ = [];\n\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n\n    if (f(x)) {\n      results$.push(x);\n    }\n  }\n\n  return results$;\n});\nreject = curry$(function (f, xs) {\n  var i$,\n      len$,\n      x,\n      results$ = [];\n\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n\n    if (!f(x)) {\n      results$.push(x);\n    }\n  }\n\n  return results$;\n});\npartition = curry$(function (f, xs) {\n  var passed, failed, i$, len$, x;\n  passed = [];\n  failed = [];\n\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n    (f(x) ? passed : failed).push(x);\n  }\n\n  return [passed, failed];\n});\nfind = curry$(function (f, xs) {\n  var i$, len$, x;\n\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n\n    if (f(x)) {\n      return x;\n    }\n  }\n});\n\nhead = first = function first(xs) {\n  return xs[0];\n};\n\ntail = function tail(xs) {\n  if (!xs.length) {\n    return;\n  }\n\n  return xs.slice(1);\n};\n\nlast = function last(xs) {\n  return xs[xs.length - 1];\n};\n\ninitial = function initial(xs) {\n  if (!xs.length) {\n    return;\n  }\n\n  return xs.slice(0, -1);\n};\n\nempty = function empty(xs) {\n  return !xs.length;\n};\n\nreverse = function reverse(xs) {\n  return xs.concat().reverse();\n};\n\nunique = function unique(xs) {\n  var result, i$, len$, x;\n  result = [];\n\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n\n    if (!in$(x, result)) {\n      result.push(x);\n    }\n  }\n\n  return result;\n};\n\nuniqueBy = curry$(function (f, xs) {\n  var seen,\n      i$,\n      len$,\n      x,\n      val,\n      results$ = [];\n  seen = [];\n\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n    val = f(x);\n\n    if (in$(val, seen)) {\n      continue;\n    }\n\n    seen.push(val);\n    results$.push(x);\n  }\n\n  return results$;\n});\nfold = foldl = curry$(function (f, memo, xs) {\n  var i$, len$, x;\n\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n    memo = f(memo, x);\n  }\n\n  return memo;\n});\nfold1 = foldl1 = curry$(function (f, xs) {\n  return fold(f, xs[0], xs.slice(1));\n});\nfoldr = curry$(function (f, memo, xs) {\n  var i$, x;\n\n  for (i$ = xs.length - 1; i$ >= 0; --i$) {\n    x = xs[i$];\n    memo = f(x, memo);\n  }\n\n  return memo;\n});\nfoldr1 = curry$(function (f, xs) {\n  return foldr(f, xs[xs.length - 1], xs.slice(0, -1));\n});\nunfoldr = curry$(function (f, b) {\n  var result, x, that;\n  result = [];\n  x = b;\n\n  while ((that = f(x)) != null) {\n    result.push(that[0]);\n    x = that[1];\n  }\n\n  return result;\n});\n\nconcat = function concat(xss) {\n  return [].concat.apply([], xss);\n};\n\nconcatMap = curry$(function (f, xs) {\n  var x;\n  return [].concat.apply([], function () {\n    var i$,\n        ref$,\n        len$,\n        results$ = [];\n\n    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {\n      x = ref$[i$];\n      results$.push(f(x));\n    }\n\n    return results$;\n  }());\n});\n\n_flatten = function flatten(xs) {\n  var x;\n  return [].concat.apply([], function () {\n    var i$,\n        ref$,\n        len$,\n        results$ = [];\n\n    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {\n      x = ref$[i$];\n\n      if (toString$.call(x).slice(8, -1) === 'Array') {\n        results$.push(_flatten(x));\n      } else {\n        results$.push(x);\n      }\n    }\n\n    return results$;\n  }());\n};\n\ndifference = function difference(xs) {\n  var yss, results, i$, len$, x, j$, len1$, ys;\n  yss = slice$.call(arguments, 1);\n  results = [];\n\n  outer: for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n\n    for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {\n      ys = yss[j$];\n\n      if (in$(x, ys)) {\n        continue outer;\n      }\n    }\n\n    results.push(x);\n  }\n\n  return results;\n};\n\nintersection = function intersection(xs) {\n  var yss, results, i$, len$, x, j$, len1$, ys;\n  yss = slice$.call(arguments, 1);\n  results = [];\n\n  outer: for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n\n    for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {\n      ys = yss[j$];\n\n      if (!in$(x, ys)) {\n        continue outer;\n      }\n    }\n\n    results.push(x);\n  }\n\n  return results;\n};\n\nunion = function union() {\n  var xss, results, i$, len$, xs, j$, len1$, x;\n  xss = slice$.call(arguments);\n  results = [];\n\n  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {\n    xs = xss[i$];\n\n    for (j$ = 0, len1$ = xs.length; j$ < len1$; ++j$) {\n      x = xs[j$];\n\n      if (!in$(x, results)) {\n        results.push(x);\n      }\n    }\n  }\n\n  return results;\n};\n\ncountBy = curry$(function (f, xs) {\n  var results, i$, len$, x, key;\n  results = {};\n\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n    key = f(x);\n\n    if (key in results) {\n      results[key] += 1;\n    } else {\n      results[key] = 1;\n    }\n  }\n\n  return results;\n});\ngroupBy = curry$(function (f, xs) {\n  var results, i$, len$, x, key;\n  results = {};\n\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n    key = f(x);\n\n    if (key in results) {\n      results[key].push(x);\n    } else {\n      results[key] = [x];\n    }\n  }\n\n  return results;\n});\n\nandList = function andList(xs) {\n  var i$, len$, x;\n\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n\n    if (!x) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\norList = function orList(xs) {\n  var i$, len$, x;\n\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n\n    if (x) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nany = curry$(function (f, xs) {\n  var i$, len$, x;\n\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n\n    if (f(x)) {\n      return true;\n    }\n  }\n\n  return false;\n});\nall = curry$(function (f, xs) {\n  var i$, len$, x;\n\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n\n    if (!f(x)) {\n      return false;\n    }\n  }\n\n  return true;\n});\n\nsort = function sort(xs) {\n  return xs.concat().sort(function (x, y) {\n    if (x > y) {\n      return 1;\n    } else if (x < y) {\n      return -1;\n    } else {\n      return 0;\n    }\n  });\n};\n\nsortWith = curry$(function (f, xs) {\n  return xs.concat().sort(f);\n});\nsortBy = curry$(function (f, xs) {\n  return xs.concat().sort(function (x, y) {\n    if (f(x) > f(y)) {\n      return 1;\n    } else if (f(x) < f(y)) {\n      return -1;\n    } else {\n      return 0;\n    }\n  });\n});\n\nsum = function sum(xs) {\n  var result, i$, len$, x;\n  result = 0;\n\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n    result += x;\n  }\n\n  return result;\n};\n\nproduct = function product(xs) {\n  var result, i$, len$, x;\n  result = 1;\n\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n    result *= x;\n  }\n\n  return result;\n};\n\nmean = average = function average(xs) {\n  var sum, i$, len$, x;\n  sum = 0;\n\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n    sum += x;\n  }\n\n  return sum / xs.length;\n};\n\nmaximum = function maximum(xs) {\n  var max, i$, ref$, len$, x;\n  max = xs[0];\n\n  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {\n    x = ref$[i$];\n\n    if (x > max) {\n      max = x;\n    }\n  }\n\n  return max;\n};\n\nminimum = function minimum(xs) {\n  var min, i$, ref$, len$, x;\n  min = xs[0];\n\n  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {\n    x = ref$[i$];\n\n    if (x < min) {\n      min = x;\n    }\n  }\n\n  return min;\n};\n\nmaximumBy = curry$(function (f, xs) {\n  var max, i$, ref$, len$, x;\n  max = xs[0];\n\n  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {\n    x = ref$[i$];\n\n    if (f(x) > f(max)) {\n      max = x;\n    }\n  }\n\n  return max;\n});\nminimumBy = curry$(function (f, xs) {\n  var min, i$, ref$, len$, x;\n  min = xs[0];\n\n  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {\n    x = ref$[i$];\n\n    if (f(x) < f(min)) {\n      min = x;\n    }\n  }\n\n  return min;\n});\nscan = scanl = curry$(function (f, memo, xs) {\n  var last, x;\n  last = memo;\n  return [memo].concat(function () {\n    var i$,\n        ref$,\n        len$,\n        results$ = [];\n\n    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {\n      x = ref$[i$];\n      results$.push(last = f(last, x));\n    }\n\n    return results$;\n  }());\n});\nscan1 = scanl1 = curry$(function (f, xs) {\n  if (!xs.length) {\n    return;\n  }\n\n  return scan(f, xs[0], xs.slice(1));\n});\nscanr = curry$(function (f, memo, xs) {\n  xs = xs.concat().reverse();\n  return scan(f, memo, xs).reverse();\n});\nscanr1 = curry$(function (f, xs) {\n  if (!xs.length) {\n    return;\n  }\n\n  xs = xs.concat().reverse();\n  return scan(f, xs[0], xs.slice(1)).reverse();\n});\nslice = curry$(function (x, y, xs) {\n  return xs.slice(x, y);\n});\ntake = curry$(function (n, xs) {\n  if (n <= 0) {\n    return xs.slice(0, 0);\n  } else {\n    return xs.slice(0, n);\n  }\n});\ndrop = curry$(function (n, xs) {\n  if (n <= 0) {\n    return xs;\n  } else {\n    return xs.slice(n);\n  }\n});\nsplitAt = curry$(function (n, xs) {\n  return [take(n, xs), drop(n, xs)];\n});\ntakeWhile = curry$(function (p, xs) {\n  var len, i;\n  len = xs.length;\n\n  if (!len) {\n    return xs;\n  }\n\n  i = 0;\n\n  while (i < len && p(xs[i])) {\n    i += 1;\n  }\n\n  return xs.slice(0, i);\n});\ndropWhile = curry$(function (p, xs) {\n  var len, i;\n  len = xs.length;\n\n  if (!len) {\n    return xs;\n  }\n\n  i = 0;\n\n  while (i < len && p(xs[i])) {\n    i += 1;\n  }\n\n  return xs.slice(i);\n});\nspan = curry$(function (p, xs) {\n  return [takeWhile(p, xs), dropWhile(p, xs)];\n});\nbreakList = curry$(function (p, xs) {\n  return span(compose$(p, not$), xs);\n});\nzip = curry$(function (xs, ys) {\n  var result, len, i$, len$, i, x;\n  result = [];\n  len = ys.length;\n\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    i = i$;\n    x = xs[i$];\n\n    if (i === len) {\n      break;\n    }\n\n    result.push([x, ys[i]]);\n  }\n\n  return result;\n});\nzipWith = curry$(function (f, xs, ys) {\n  var result, len, i$, len$, i, x;\n  result = [];\n  len = ys.length;\n\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    i = i$;\n    x = xs[i$];\n\n    if (i === len) {\n      break;\n    }\n\n    result.push(f(x, ys[i]));\n  }\n\n  return result;\n});\n\nzipAll = function zipAll() {\n  var xss,\n      minLength,\n      i$,\n      len$,\n      xs,\n      ref$,\n      i,\n      lresult$,\n      j$,\n      results$ = [];\n  xss = slice$.call(arguments);\n  minLength = undefined;\n\n  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {\n    xs = xss[i$];\n    minLength <= (ref$ = xs.length) || (minLength = ref$);\n  }\n\n  for (i$ = 0; i$ < minLength; ++i$) {\n    i = i$;\n    lresult$ = [];\n\n    for (j$ = 0, len$ = xss.length; j$ < len$; ++j$) {\n      xs = xss[j$];\n      lresult$.push(xs[i]);\n    }\n\n    results$.push(lresult$);\n  }\n\n  return results$;\n};\n\nzipAllWith = function zipAllWith(f) {\n  var xss,\n      minLength,\n      i$,\n      len$,\n      xs,\n      ref$,\n      i,\n      results$ = [];\n  xss = slice$.call(arguments, 1);\n  minLength = undefined;\n\n  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {\n    xs = xss[i$];\n    minLength <= (ref$ = xs.length) || (minLength = ref$);\n  }\n\n  for (i$ = 0; i$ < minLength; ++i$) {\n    i = i$;\n    results$.push(f.apply(null, fn$()));\n  }\n\n  return results$;\n\n  function fn$() {\n    var i$,\n        ref$,\n        len$,\n        results$ = [];\n\n    for (i$ = 0, len$ = (ref$ = xss).length; i$ < len$; ++i$) {\n      xs = ref$[i$];\n      results$.push(xs[i]);\n    }\n\n    return results$;\n  }\n};\n\nat = curry$(function (n, xs) {\n  if (n < 0) {\n    return xs[xs.length + n];\n  } else {\n    return xs[n];\n  }\n});\nelemIndex = curry$(function (el, xs) {\n  var i$, len$, i, x;\n\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    i = i$;\n    x = xs[i$];\n\n    if (x === el) {\n      return i;\n    }\n  }\n});\nelemIndices = curry$(function (el, xs) {\n  var i$,\n      len$,\n      i,\n      x,\n      results$ = [];\n\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    i = i$;\n    x = xs[i$];\n\n    if (x === el) {\n      results$.push(i);\n    }\n  }\n\n  return results$;\n});\nfindIndex = curry$(function (f, xs) {\n  var i$, len$, i, x;\n\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    i = i$;\n    x = xs[i$];\n\n    if (f(x)) {\n      return i;\n    }\n  }\n});\nfindIndices = curry$(function (f, xs) {\n  var i$,\n      len$,\n      i,\n      x,\n      results$ = [];\n\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    i = i$;\n    x = xs[i$];\n\n    if (f(x)) {\n      results$.push(i);\n    }\n  }\n\n  return results$;\n});\nmodule.exports = {\n  each: each,\n  map: map,\n  filter: filter,\n  compact: compact,\n  reject: reject,\n  partition: partition,\n  find: find,\n  head: head,\n  first: first,\n  tail: tail,\n  last: last,\n  initial: initial,\n  empty: empty,\n  reverse: reverse,\n  difference: difference,\n  intersection: intersection,\n  union: union,\n  countBy: countBy,\n  groupBy: groupBy,\n  fold: fold,\n  fold1: fold1,\n  foldl: foldl,\n  foldl1: foldl1,\n  foldr: foldr,\n  foldr1: foldr1,\n  unfoldr: unfoldr,\n  andList: andList,\n  orList: orList,\n  any: any,\n  all: all,\n  unique: unique,\n  uniqueBy: uniqueBy,\n  sort: sort,\n  sortWith: sortWith,\n  sortBy: sortBy,\n  sum: sum,\n  product: product,\n  mean: mean,\n  average: average,\n  concat: concat,\n  concatMap: concatMap,\n  flatten: _flatten,\n  maximum: maximum,\n  minimum: minimum,\n  maximumBy: maximumBy,\n  minimumBy: minimumBy,\n  scan: scan,\n  scan1: scan1,\n  scanl: scanl,\n  scanl1: scanl1,\n  scanr: scanr,\n  scanr1: scanr1,\n  slice: slice,\n  take: take,\n  drop: drop,\n  splitAt: splitAt,\n  takeWhile: takeWhile,\n  dropWhile: dropWhile,\n  span: span,\n  breakList: breakList,\n  zip: zip,\n  zipWith: zipWith,\n  zipAll: zipAll,\n  zipAllWith: zipAllWith,\n  at: at,\n  elemIndex: elemIndex,\n  elemIndices: elemIndices,\n  findIndex: findIndex,\n  findIndices: findIndices\n};\n\nfunction curry$(f, bound) {\n  var context,\n      _curry = function _curry(args) {\n    return f.length > 1 ? function () {\n      var params = args ? args.concat() : [];\n      context = bound ? context || this : this;\n      return params.push.apply(params, arguments) < f.length && arguments.length ? _curry.call(context, params) : f.apply(context, params);\n    } : f;\n  };\n\n  return _curry();\n}\n\nfunction in$(x, xs) {\n  var i = -1,\n      l = xs.length >>> 0;\n\n  while (++i < l) {\n    if (x === xs[i]) return true;\n  }\n\n  return false;\n}\n\nfunction compose$() {\n  var functions = arguments;\n  return function () {\n    var i, result;\n    result = functions[0].apply(this, arguments);\n\n    for (i = 1; i < functions.length; ++i) {\n      result = functions[i](result);\n    }\n\n    return result;\n  };\n}\n\nfunction not$(x) {\n  return !x;\n}","map":null,"metadata":{},"sourceType":"script"}